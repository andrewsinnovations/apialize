const {
  getProvidedValues,
  getOwnershipWhere,
  buildWhereClause,
  copyOwnProperties,
  extractIdFromRequest,
  extractRawAttributes,
  handleValidationError,
  extractAffectedCount,
  validateAllowedFields,
} = require('../utils');
const { validateData } = require('../validationMiddleware');
const {
  optionsWithTransaction,
  notFoundWithRollback,
  reverseMapForeignKeys,
} = require('../operationUtils');
const { mapFieldsToInternal } = require('../fieldAliasUtils');

function removeIdMappingFromProvided(provided, idMapping) {
  const hasIdMappingProperty = Object.prototype.hasOwnProperty.call(
    provided,
    idMapping
  );
  if (hasIdMappingProperty) {
    delete provided[idMapping];
  }
}

function isFieldUpdatable(key, rawAttributes, idMapping) {
  const hasAttribute = Object.prototype.hasOwnProperty.call(rawAttributes, key);
  const isIdMappingField = key === idMapping;

  const attributeExists = rawAttributes[key];
  const isAutoGenerated = attributeExists && rawAttributes[key]._autoGenerated;

  const canUpdate = hasAttribute && !isIdMappingField && !isAutoGenerated;
  return canUpdate;
}

function getUpdatableKeys(provided, rawAttributes, idMapping) {
  const updatableKeys = [];
  const providedKeys = Object.keys(provided);

  for (let i = 0; i < providedKeys.length; i += 1) {
    const key = providedKeys[i];
    const canUpdateField = isFieldUpdatable(key, rawAttributes, idMapping);

    if (canUpdateField) {
      updatableKeys.push(key);
    }
  }

  return updatableKeys;
}

function createFindOptions(modelOptions, idMapping, id, transaction) {
  const findOptions = {};
  copyOwnProperties(modelOptions, findOptions);

  findOptions.where = {};
  findOptions.where[idMapping] = id;
  findOptions.attributes = [idMapping];

  return optionsWithTransaction(findOptions, transaction);
}

async function handleNoUpdatableKeys(
  model,
  modelOptions,
  idMapping,
  id,
  context
) {
  const findOptions = createFindOptions(
    modelOptions,
    idMapping,
    id,
    context.transaction
  );

  const exists = await model.findOne(findOptions);
  const recordNotFound = !exists;
  if (recordNotFound) {
    return notFoundWithRollback(context);
  }

  context.payload = { success: true, id: id };
}

function createUpdateOptions(
  modelOptions,
  ownershipWhere,
  idMapping,
  id,
  updatableKeys,
  transaction
) {
  const updateOptions = {};
  copyOwnProperties(modelOptions, updateOptions);

  const where = buildWhereClause(ownershipWhere, idMapping, id);
  updateOptions.where = where;
  updateOptions.fields = updatableKeys.slice();

  return optionsWithTransaction(updateOptions, transaction);
}

async function handleUpdatableKeys(
  model,
  provided,
  modelOptions,
  ownershipWhere,
  idMapping,
  id,
  updatableKeys,
  context
) {
  const updateOptions = createUpdateOptions(
    modelOptions,
    ownershipWhere,
    idMapping,
    id,
    updatableKeys,
    context.transaction
  );

  const updateResult = await model.update(provided, updateOptions);
  const affected = extractAffectedCount(updateResult);
  return affected;
}

async function validatePatchData(model, provided, validate, res) {
  const shouldValidate = validate;
  if (!shouldValidate) {
    return true;
  }

  try {
    await validateData(model, provided, { isPartial: true });
    return true;
  } catch (error) {
    return handleValidationError(error, res);
  }
}

async function processPatchRequest(context, config, req, res) {
  const id = extractIdFromRequest(req);
  const requestBody = req.body || {};
  
  // Validate allowed/blocked fields on request body BEFORE mapping (using external names)
  if (config.aliases) {
    const { checkFieldAllowed } = require('../fieldAliasUtils');
    
    const fieldNames = Object.keys(requestBody);
    for (const fieldName of fieldNames) {
      const fieldCheck = checkFieldAllowed(
        fieldName,
        config.allowedFields,
        config.blockedFields,
        config.aliases
      );
      if (!fieldCheck.allowed) {
        context.res.status(400).json({
          success: false,
          error: fieldCheck.error,
        });
        return;
      }
    }
  } else {
    // Standard validation without aliases
    const fieldValidation = validateAllowedFields(
      requestBody,
      config.allowedFields,
      config.blockedFields
    );
    if (!fieldValidation.valid) {
      context.res.status(400).json({
        success: false,
        error: fieldValidation.error,
      });
      return;
    }
  }
  
  // Map external field names to internal names if aliases are configured
  if (config.aliases && req.body) {
    req.body = mapFieldsToInternal(req.body, config.aliases);
    // Also update req.apialize.values if it exists
    if (req.apialize) {
      req.apialize.values = req.body;
    }
  }
  
  const provided = getProvidedValues(req);

  // Reverse-map foreign key fields from external IDs to internal IDs
  try {
    await reverseMapForeignKeys(
      provided,
      context.model,
      config.relation_id_mapping,
      context.transaction
    );
  } catch (error) {
    context.res.status(400).json({
      success: false,
      error: error.message || 'Invalid foreign key reference',
    });
    return;
  }

  const isValid = await validatePatchData(
    context.model,
    provided,
    config.validate,
    context.res
  );
  if (!isValid) {
    return;
  }

  removeIdMappingFromProvided(provided, config.id_mapping);
  const rawAttributes = extractRawAttributes(context.model);
  const updatableKeys = getUpdatableKeys(
    provided,
    rawAttributes,
    config.id_mapping
  );

  const ownershipWhere = getOwnershipWhere(req);
  const hasNoUpdatableKeys = updatableKeys.length === 0;

  if (hasNoUpdatableKeys) {
    await handleNoUpdatableKeys(
      context.model,
      context.modelOptions,
      config.id_mapping,
      id,
      context
    );
  } else {
    const affected = await handleUpdatableKeys(
      context.model,
      provided,
      context.modelOptions,
      ownershipWhere,
      config.id_mapping,
      id,
      updatableKeys,
      context
    );

    const noRecordsAffected = !affected;
    if (noRecordsAffected) {
      return notFoundWithRollback(context);
    }

    context.payload = { success: true, id: id };
  }

  return context.payload;
}

module.exports = {
  processPatchRequest,
};

