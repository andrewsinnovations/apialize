const {
  getProvidedValues,
  getOwnershipWhere,
  buildWhereClause,
  copyOwnProperties,
  extractIdFromRequest,
  extractRawAttributes,
  handleValidationError,
  extractAffectedCount,
} = require('../utils');
const { validateData } = require('../validationMiddleware');
const {
  optionsWithTransaction,
  notFoundWithRollback,
} = require('../operationUtils');

function removeIdMappingFromProvided(provided, idMapping) {
  const hasIdMappingProperty = Object.prototype.hasOwnProperty.call(
    provided,
    idMapping
  );
  if (hasIdMappingProperty) {
    delete provided[idMapping];
  }
}

function isFieldUpdatable(key, rawAttributes, idMapping) {
  const hasAttribute = Object.prototype.hasOwnProperty.call(rawAttributes, key);
  const isIdMappingField = key === idMapping;

  const attributeExists = rawAttributes[key];
  const isAutoGenerated = attributeExists && rawAttributes[key]._autoGenerated;

  const canUpdate = hasAttribute && !isIdMappingField && !isAutoGenerated;
  return canUpdate;
}

function getUpdatableKeys(provided, rawAttributes, idMapping) {
  const updatableKeys = [];
  const providedKeys = Object.keys(provided);

  for (let i = 0; i < providedKeys.length; i += 1) {
    const key = providedKeys[i];
    const canUpdateField = isFieldUpdatable(key, rawAttributes, idMapping);

    if (canUpdateField) {
      updatableKeys.push(key);
    }
  }

  return updatableKeys;
}

function createFindOptions(modelOptions, idMapping, id, transaction) {
  const findOptions = {};
  copyOwnProperties(modelOptions, findOptions);

  findOptions.where = {};
  findOptions.where[idMapping] = id;
  findOptions.attributes = [idMapping];

  return optionsWithTransaction(findOptions, transaction);
}

async function handleNoUpdatableKeys(
  model,
  modelOptions,
  idMapping,
  id,
  context
) {
  const findOptions = createFindOptions(
    modelOptions,
    idMapping,
    id,
    context.transaction
  );

  const exists = await model.findOne(findOptions);
  const recordNotFound = !exists;
  if (recordNotFound) {
    return notFoundWithRollback(context);
  }

  context.payload = { success: true, id: id };
}

function createUpdateOptions(
  modelOptions,
  ownershipWhere,
  idMapping,
  id,
  updatableKeys,
  transaction
) {
  const updateOptions = {};
  copyOwnProperties(modelOptions, updateOptions);

  const where = buildWhereClause(ownershipWhere, idMapping, id);
  updateOptions.where = where;
  updateOptions.fields = updatableKeys.slice();

  return optionsWithTransaction(updateOptions, transaction);
}

async function handleUpdatableKeys(
  model,
  provided,
  modelOptions,
  ownershipWhere,
  idMapping,
  id,
  updatableKeys,
  context
) {
  const updateOptions = createUpdateOptions(
    modelOptions,
    ownershipWhere,
    idMapping,
    id,
    updatableKeys,
    context.transaction
  );

  const updateResult = await model.update(provided, updateOptions);
  const affected = extractAffectedCount(updateResult);
  return affected;
}

async function validatePatchData(model, provided, validate, res) {
  const shouldValidate = validate;
  if (!shouldValidate) {
    return true;
  }

  try {
    await validateData(model, provided, { isPartial: true });
    return true;
  } catch (error) {
    return handleValidationError(error, res);
  }
}

async function processPatchRequest(context, config, req, res) {
  const id = extractIdFromRequest(req);
  const provided = getProvidedValues(req);

  const isValid = await validatePatchData(
    context.model,
    provided,
    config.validate,
    context.res
  );
  if (!isValid) {
    return;
  }

  removeIdMappingFromProvided(provided, config.id_mapping);
  const rawAttributes = extractRawAttributes(context.model);
  const updatableKeys = getUpdatableKeys(
    provided,
    rawAttributes,
    config.id_mapping
  );

  const ownershipWhere = getOwnershipWhere(req);
  const hasNoUpdatableKeys = updatableKeys.length === 0;

  if (hasNoUpdatableKeys) {
    await handleNoUpdatableKeys(
      context.model,
      context.modelOptions,
      config.id_mapping,
      id,
      context
    );
  } else {
    const affected = await handleUpdatableKeys(
      context.model,
      provided,
      context.modelOptions,
      ownershipWhere,
      config.id_mapping,
      id,
      updatableKeys,
      context
    );

    const noRecordsAffected = !affected;
    if (noRecordsAffected) {
      return notFoundWithRollback(context);
    }

    context.payload = { success: true, id: id };
  }

  return context.payload;
}

module.exports = {
  processPatchRequest,
};
