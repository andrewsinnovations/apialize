const {
  getProvidedValues,
  getOwnershipWhere,
  buildWhereClause,
  handleValidationError,
  validateAllowedFields,
} = require('../utils');
const { validateData } = require('../validationMiddleware');
const {
  optionsWithTransaction,
  notFoundWithRollback,
  reverseMapForeignKeys,
} = require('../operationUtils');
const { mapFieldsToInternal } = require('../fieldAliasUtils');

/**
 * Gets updatable attributes from model
 */
function getUpdatableAttributes(model, idMapping) {
  const rawAttributes = model.constructor.rawAttributes;
  const updatableAttributes = [];
  const attributeNames = Object.keys(rawAttributes);

  for (let i = 0; i < attributeNames.length; i++) {
    const attributeName = attributeNames[i];
    const isIdField = attributeName === idMapping;
    const isAutoGenerated = rawAttributes[attributeName]._autoGenerated;
    const canBeUpdated = !isIdField && !isAutoGenerated;

    if (canBeUpdated) {
      updatableAttributes.push(attributeName);
    }
  }

  return updatableAttributes;
}

/**
 * Sets attribute value with defaults
 */
function setAttributeValue(
  nextValues,
  attributeName,
  providedValues,
  rawAttributes
) {
  const hasProvidedValue = Object.prototype.hasOwnProperty.call(
    providedValues,
    attributeName
  );
  if (hasProvidedValue) {
    nextValues[attributeName] = providedValues[attributeName];
    return;
  }

  const defaultValue = rawAttributes[attributeName].defaultValue;
  const hasDefaultValue = typeof defaultValue !== 'undefined';
  if (hasDefaultValue) {
    nextValues[attributeName] = defaultValue;
  } else {
    nextValues[attributeName] = null;
  }
}

/**
 * Builds next values object
 */
function buildNextValues(
  updatableAttributes,
  providedValues,
  rawAttributes,
  idMapping,
  id
) {
  const nextValues = {};

  for (let i = 0; i < updatableAttributes.length; i++) {
    const attributeName = updatableAttributes[i];
    setAttributeValue(nextValues, attributeName, providedValues, rawAttributes);
  }

  nextValues[idMapping] = id;
  return nextValues;
}

/**
 * Validates ownership
 */
function validateOwnership(instance, ownershipWhere) {
  const hasOwnershipRules =
    ownershipWhere && Object.keys(ownershipWhere).length > 0;
  if (!hasOwnershipRules) {
    return true;
  }

  const ownershipEntries = Object.entries(ownershipWhere);
  for (let i = 0; i < ownershipEntries.length; i++) {
    const [key, expectedValue] = ownershipEntries[i];
    const actualValue = instance[key];

    // Use type-coerced comparison to handle query params (strings) vs instance values (typed)
    // This allows ownership validation to work when query params like ?user_id=1 are compared
    // with integer fields in the database
    const valuesMatch = actualValue == expectedValue;

    if (!valuesMatch) {
      return false;
    }
  }

  return true;
}

/**
 * Finds existing record
 */
function findExistingRecord(
  context,
  modelOptions,
  ownershipWhere,
  idMapping,
  id
) {
  const where = buildWhereClause(ownershipWhere, idMapping, id);
  const findModelOptions = Object.assign({}, modelOptions, { where });
  const findOptions = optionsWithTransaction(
    findModelOptions,
    context.transaction
  );

  return context.model.findOne(findOptions);
}

/**
 * Saves updated record
 */
function saveUpdatedRecord(
  existingInstance,
  nextValues,
  modelOptions,
  context
) {
  const fieldsToUpdate = Object.keys(nextValues);
  const saveModelOptions = Object.assign({}, modelOptions, {
    fields: fieldsToUpdate,
  });
  const saveOptions = optionsWithTransaction(
    saveModelOptions,
    context.transaction
  );

  return existingInstance.save(saveOptions);
}

/**
 * Main update request processor
 * @param {Object} context - Transaction and hooks context
 * @param {Object} config - Operation configuration
 * @param {Object} req - Express request
 * @param {Object} res - Express response
 * @returns {Object} Response payload
 */
async function processUpdateRequest(context, config, req, res) {
  const id = req.params.id;
  const requestBody = req.body || {};
  
  // Validate allowed/blocked fields on request body BEFORE mapping (using external names)
  if (config.aliases) {
    const { checkFieldAllowed } = require('../fieldAliasUtils');
    
    const fieldNames = Object.keys(requestBody);
    for (const fieldName of fieldNames) {
      const fieldCheck = checkFieldAllowed(
        fieldName,
        config.allowedFields,
        config.blockedFields,
        config.aliases
      );
      if (!fieldCheck.allowed) {
        context.res.status(400).json({
          success: false,
          error: fieldCheck.error,
        });
        return;
      }
    }
  } else {
    // Standard validation without aliases
    const fieldValidation = validateAllowedFields(
      requestBody,
      config.allowedFields,
      config.blockedFields
    );
    if (!fieldValidation.valid) {
      context.res.status(400).json({
        success: false,
        error: fieldValidation.error,
      });
      return;
    }
  }
  
  // Map external field names to internal names if aliases are configured
  if (config.aliases && req.body) {
    req.body = mapFieldsToInternal(req.body, config.aliases);
    // Also update req.apialize.values if it exists
    if (req.apialize) {
      req.apialize.values = req.body;
    }
  }
  
  const providedValues = getProvidedValues(req);
  const ownershipWhere = getOwnershipWhere(req);

  // Reverse-map foreign key fields from external IDs to internal IDs
  try {
    await reverseMapForeignKeys(
      providedValues,
      context.model,
      config.relation_id_mapping,
      context.transaction
    );
  } catch (error) {
    context.res.status(400).json({
      success: false,
      error: error.message || 'Invalid foreign key reference',
    });
    return;
  }

  const existingInstance = await findExistingRecord(
    context,
    context.modelOptions,
    ownershipWhere,
    config.id_mapping,
    id
  );

  const recordExists = existingInstance != null;
  if (!recordExists) {
    return notFoundWithRollback(context);
  }
  context.existing = existingInstance;

  if (config.validate) {
    try {
      await validateData(context.model, providedValues, { isPartial: false });
    } catch (error) {
      const wasHandled = handleValidationError(error, context);
      if (wasHandled) {
        return;
      }
      throw error;
    }
  }

  const updatableAttributes = getUpdatableAttributes(
    existingInstance,
    config.id_mapping
  );
  const rawAttributes = existingInstance.constructor.rawAttributes;
  const nextValues = buildNextValues(
    updatableAttributes,
    providedValues,
    rawAttributes,
    config.id_mapping,
    id
  );

  existingInstance.set(nextValues);
  context.nextValues = nextValues;

  const isOwnershipValid = validateOwnership(existingInstance, ownershipWhere);
  if (!isOwnershipValid) {
    return notFoundWithRollback(context);
  }

  await saveUpdatedRecord(
    existingInstance,
    nextValues,
    context.modelOptions,
    context
  );

  context.payload = { success: true };
  return context.payload;
}

module.exports = {
  processUpdateRequest,
};

