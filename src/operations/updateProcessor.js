const {
  getProvidedValues,
  getOwnershipWhere,
  buildWhereClause,
  handleValidationError,
} = require('../utils');
const { validateData } = require('../validationMiddleware');
const {
  optionsWithTransaction,
  notFoundWithRollback,
} = require('../operationUtils');

/**
 * Gets updatable attributes from model
 */
function getUpdatableAttributes(model, idMapping) {
  const rawAttributes = model.constructor.rawAttributes;
  const updatableAttributes = [];
  const attributeNames = Object.keys(rawAttributes);

  for (let i = 0; i < attributeNames.length; i++) {
    const attributeName = attributeNames[i];
    const isIdField = attributeName === idMapping;
    const isAutoGenerated = rawAttributes[attributeName]._autoGenerated;
    const canBeUpdated = !isIdField && !isAutoGenerated;

    if (canBeUpdated) {
      updatableAttributes.push(attributeName);
    }
  }

  return updatableAttributes;
}

/**
 * Sets attribute value with defaults
 */
function setAttributeValue(
  nextValues,
  attributeName,
  providedValues,
  rawAttributes
) {
  const hasProvidedValue = Object.prototype.hasOwnProperty.call(
    providedValues,
    attributeName
  );
  if (hasProvidedValue) {
    nextValues[attributeName] = providedValues[attributeName];
    return;
  }

  const defaultValue = rawAttributes[attributeName].defaultValue;
  const hasDefaultValue = typeof defaultValue !== 'undefined';
  if (hasDefaultValue) {
    nextValues[attributeName] = defaultValue;
  } else {
    nextValues[attributeName] = null;
  }
}

/**
 * Builds next values object
 */
function buildNextValues(
  updatableAttributes,
  providedValues,
  rawAttributes,
  idMapping,
  id
) {
  const nextValues = {};

  for (let i = 0; i < updatableAttributes.length; i++) {
    const attributeName = updatableAttributes[i];
    setAttributeValue(nextValues, attributeName, providedValues, rawAttributes);
  }

  nextValues[idMapping] = id;
  return nextValues;
}

/**
 * Validates ownership
 */
function validateOwnership(instance, ownershipWhere) {
  const hasOwnershipRules =
    ownershipWhere && Object.keys(ownershipWhere).length > 0;
  if (!hasOwnershipRules) {
    return true;
  }

  const ownershipEntries = Object.entries(ownershipWhere);
  for (let i = 0; i < ownershipEntries.length; i++) {
    const [key, expectedValue] = ownershipEntries[i];
    const actualValue = instance[key];
    const valuesMatch = actualValue === expectedValue;

    if (!valuesMatch) {
      return false;
    }
  }

  return true;
}

/**
 * Finds existing record
 */
function findExistingRecord(
  context,
  modelOptions,
  ownershipWhere,
  idMapping,
  id
) {
  const where = buildWhereClause(ownershipWhere, idMapping, id);
  const findModelOptions = Object.assign({}, modelOptions, { where });
  const findOptions = optionsWithTransaction(
    findModelOptions,
    context.transaction
  );

  return context.model.findOne(findOptions);
}

/**
 * Saves updated record
 */
function saveUpdatedRecord(
  existingInstance,
  nextValues,
  modelOptions,
  context
) {
  const fieldsToUpdate = Object.keys(nextValues);
  const saveModelOptions = Object.assign({}, modelOptions, {
    fields: fieldsToUpdate,
  });
  const saveOptions = optionsWithTransaction(
    saveModelOptions,
    context.transaction
  );

  return existingInstance.save(saveOptions);
}

/**
 * Main update request processor
 * @param {Object} context - Transaction and hooks context
 * @param {Object} config - Operation configuration
 * @param {Object} req - Express request
 * @param {Object} res - Express response
 * @returns {Object} Response payload
 */
async function processUpdateRequest(context, config, req, res) {
  const id = req.params.id;
  const providedValues = getProvidedValues(req);
  const ownershipWhere = getOwnershipWhere(req);

  const existingInstance = await findExistingRecord(
    context,
    context.modelOptions,
    ownershipWhere,
    config.id_mapping,
    id
  );

  const recordExists = existingInstance != null;
  if (!recordExists) {
    return notFoundWithRollback(context);
  }
  context.existing = existingInstance;

  if (config.validate) {
    try {
      await validateData(context.model, providedValues, { isPartial: false });
    } catch (error) {
      const wasHandled = handleValidationError(error, context);
      if (wasHandled) {
        return;
      }
      throw error;
    }
  }

  const updatableAttributes = getUpdatableAttributes(
    existingInstance,
    config.id_mapping
  );
  const rawAttributes = existingInstance.constructor.rawAttributes;
  const nextValues = buildNextValues(
    updatableAttributes,
    providedValues,
    rawAttributes,
    config.id_mapping,
    id
  );

  existingInstance.set(nextValues);
  context.nextValues = nextValues;

  const isOwnershipValid = validateOwnership(existingInstance, ownershipWhere);
  if (!isOwnershipValid) {
    return notFoundWithRollback(context);
  }

  await saveUpdatedRecord(
    existingInstance,
    nextValues,
    context.modelOptions,
    context
  );

  context.payload = { success: true };
  return context.payload;
}

module.exports = {
  processUpdateRequest,
};
