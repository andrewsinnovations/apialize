const {
  express,
  apializeContext,
  ensureFn,
  asyncHandler,
  defaultNotFound,
} = require("./utils");
const {
  withTransactionAndHooks,
  optionsWithTransaction,
  notFoundWithRollback,
} = require("./operationUtils");

function update(model, options = {}, modelOptions = {}) {
  ensureFn(model, "update");
  const {
    middleware = [],
    id_mapping = "id",
    pre = null,
    post = null,
  } = options;
  const inline = middleware.filter((fn) => typeof fn === "function");
  const router = express.Router({ mergeParams: true });
  router.put(
    "/:id",
    apializeContext,
    ...inline,
    asyncHandler(async (req, res) => {
      const id = req.params.id;
      const provided =
        (req.apialize && (req.apialize.body || req.apialize.values)) ||
        req.body ||
        {};
      const ownershipWhere =
        (req.apialize.options && req.apialize.options.where) || {};

      const payload = await withTransactionAndHooks(
        {
          model,
          options: { ...options, pre, post },
          req,
          res,
          modelOptions,
          idMapping: id_mapping,
        },
        async (context) => {
          const findOptions = optionsWithTransaction(
            { ...modelOptions, where: { ...ownershipWhere, [id_mapping]: id } },
            context.transaction,
          );
          const existing = await model.findOne(findOptions);
          if (!existing) {
            return notFoundWithRollback(context);
          }
          context.existing = existing;

          const allAttrs = Object.keys(
            existing.constructor.rawAttributes,
          ).filter(
            (a) =>
              a !== id_mapping &&
              !existing.constructor.rawAttributes[a]._autoGenerated,
          );
          const nextValues = {};
          for (const attr of allAttrs) {
            if (Object.prototype.hasOwnProperty.call(provided, attr)) {
              nextValues[attr] = provided[attr];
            } else {
              const def = existing.constructor.rawAttributes[attr].defaultValue;
              nextValues[attr] = typeof def !== "undefined" ? def : null;
            }
          }
          nextValues[id_mapping] = id;
          existing.set(nextValues);
          context.nextValues = nextValues;

          if (ownershipWhere && Object.keys(ownershipWhere).length) {
            for (const [k, v] of Object.entries(ownershipWhere)) {
              if (existing[k] !== v) {
                return notFoundWithRollback(context);
              }
            }
          }

          const saveOptions = optionsWithTransaction(
            { ...modelOptions, fields: Object.keys(nextValues) },
            context.transaction,
          );
          await existing.save(saveOptions);

          context.payload = { success: true };
          return context.payload;
        },
      );
      if (!res.headersSent) {
        res.json(payload);
      }
    }),
  );
  router.apialize = {};
  return router;
}

module.exports = update;
