const {
  express,
  apializeContext,
  ensureFn,
  asyncHandler,
  defaultNotFound,
  filterMiddlewareFns,
  buildHandlers,
  getProvidedValues,
  getOwnershipWhere,
} = require('./utils');
const {
  withTransactionAndHooks,
  optionsWithTransaction,
  notFoundWithRollback,
} = require('./operationUtils');

function update(model, options = {}, modelOptions = {}) {
  ensureFn(model, 'update');
  const {
    middleware = [],
    id_mapping = 'id',
    pre = null,
    post = null,
  } = options;

  const inline = filterMiddlewareFns(middleware);
  const router = express.Router({ mergeParams: true });
  const handlers = buildHandlers(inline, async function (req, res) {
    const combinedOptions = Object.assign({}, options, { pre, post });

    const payload = await withTransactionAndHooks(
      {
        model,
        options: combinedOptions,
        req,
        res,
        modelOptions,
        idMapping: id_mapping,
      },
      async (context) => {
        // Extract data after pre-hooks (so pre-hooks can modify them)
        const id = req.params.id;
        const provided = getProvidedValues(req);
        const ownershipWhere = getOwnershipWhere(req);

        const where = Object.assign({}, ownershipWhere);
        where[id_mapping] = id;
        const findModelOptions = Object.assign({}, modelOptions, { where });
        const findOptions = optionsWithTransaction(
          findModelOptions,
          context.transaction
        );

        const existing = await model.findOne(findOptions);
        if (!existing) {
          return notFoundWithRollback(context);
        }
        context.existing = existing;

        const rawAttrs = existing.constructor.rawAttributes;
        const allAttrs = [];
        for (const attrName of Object.keys(rawAttrs)) {
          if (attrName !== id_mapping && !rawAttrs[attrName]._autoGenerated) {
            allAttrs.push(attrName);
          }
        }

        const nextValues = {};
        for (const attr of allAttrs) {
          if (Object.prototype.hasOwnProperty.call(provided, attr)) {
            nextValues[attr] = provided[attr];
          } else {
            const def = rawAttrs[attr].defaultValue;
            nextValues[attr] = typeof def !== 'undefined' ? def : null;
          }
        }
        nextValues[id_mapping] = id;
        existing.set(nextValues);
        context.nextValues = nextValues;

        if (ownershipWhere && Object.keys(ownershipWhere).length) {
          for (const [k, v] of Object.entries(ownershipWhere)) {
            if (existing[k] !== v) {
              return notFoundWithRollback(context);
            }
          }
        }

        const fields = Object.keys(nextValues);
        const saveModelOptions = Object.assign({}, modelOptions, { fields });
        const saveOptions = optionsWithTransaction(
          saveModelOptions,
          context.transaction
        );
        await existing.save(saveOptions);

        context.payload = { success: true };
        return context.payload;
      }
    );
    if (!res.headersSent) {
      res.json(payload);
    }
  });
  router.put('/:id', handlers);
  router.apialize = {};
  return router;
}

module.exports = update;
