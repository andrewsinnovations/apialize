const {
  express,
  apializeContext,
  ensureFn,
  asyncHandler,
  defaultNotFound,
  getProvidedValues,
  getOwnershipWhere,
  filterMiddlewareFns,
} = require('./utils');
const {
  withTransactionAndHooks,
  optionsWithTransaction,
  notFoundWithRollback,
} = require('./operationUtils');

function patch(model, options = {}, modelOptions = {}) {
  ensureFn(model, 'update');
  const middleware = Array.isArray(options.middleware)
    ? options.middleware
    : [];
  const id_mapping = Object.prototype.hasOwnProperty.call(options, 'id_mapping')
    ? options.id_mapping
    : 'id';
  const pre = Object.prototype.hasOwnProperty.call(options, 'pre')
    ? options.pre
    : null;
  const post = Object.prototype.hasOwnProperty.call(options, 'post')
    ? options.post
    : null;

  const inline = filterMiddlewareFns(middleware);
  const router = express.Router({ mergeParams: true });
  router.patch(
    '/:id',
    apializeContext,
    ...inline,
    asyncHandler(async (req, res) => {
      const payload = await withTransactionAndHooks(
        {
          model,
          options: Object.assign({}, options, { pre: pre, post: post }),
          req,
          res,
          modelOptions,
          idMapping: id_mapping,
        },
        async (context) => {
          // Extract all data after pre-hooks (so pre-hooks can modify them)
          const id = req.params.id;
          const provided = getProvidedValues(req);

          if (Object.prototype.hasOwnProperty.call(provided, id_mapping)) {
            delete provided[id_mapping];
          }

          let rawAttrs = {};
          if (model && model.rawAttributes) {
            rawAttrs = model.rawAttributes;
          } else if (
            model &&
            model.prototype &&
            model.prototype.rawAttributes
          ) {
            rawAttrs = model.prototype.rawAttributes;
          }

          const updatableKeys = [];
          const providedKeys = Object.keys(provided);
          for (let i = 0; i < providedKeys.length; i += 1) {
            const k = providedKeys[i];
            const hasAttr = Object.prototype.hasOwnProperty.call(rawAttrs, k);
            const isIdMapping = k === id_mapping;
            const isAutoGenerated = !!(
              rawAttrs[k] && rawAttrs[k]._autoGenerated
            );
            if (hasAttr && !isIdMapping && !isAutoGenerated) {
              updatableKeys.push(k);
            }
          }

          const ownershipWhere = getOwnershipWhere(req);
          if (updatableKeys.length === 0) {
            const findOptionsBase = Object.assign({}, modelOptions);
            findOptionsBase.where = {};
            findOptionsBase.where[id_mapping] = id;
            findOptionsBase.attributes = [id_mapping];
            const findOptions = optionsWithTransaction(
              findOptionsBase,
              context.transaction
            );
            const exists = await model.findOne(findOptions);
            if (!exists) {
              return notFoundWithRollback(context);
            }
            context.payload = { success: true, id: id };
          } else {
            const updateOptionsBase = Object.assign({}, modelOptions);
            const where = {};
            if (ownershipWhere && typeof ownershipWhere === 'object') {
              for (const key in ownershipWhere) {
                if (Object.prototype.hasOwnProperty.call(ownershipWhere, key)) {
                  where[key] = ownershipWhere[key];
                }
              }
            }
            where[id_mapping] = id;
            updateOptionsBase.where = where;
            updateOptionsBase.fields = updatableKeys.slice();
            const updateOptions = optionsWithTransaction(
              updateOptionsBase,
              context.transaction
            );
            const updateResult = await model.update(provided, updateOptions);
            const affected = Array.isArray(updateResult)
              ? updateResult[0]
              : updateResult;
            if (!affected) {
              return notFoundWithRollback(context);
            }
            context.payload = { success: true, id: id };
          }
          return context.payload;
        }
      );
      if (!res.headersSent) {
        res.json(payload);
      }
    })
  );
  router.apialize = {};
  return router;
}

module.exports = patch;
