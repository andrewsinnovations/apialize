const {
  express,
  apializeContext,
  ensureFn,
  asyncHandler,
  defaultNotFound,
  getProvidedValues,
  getOwnershipWhere,
  filterMiddlewareFns,
  extractMiddleware,
  extractOption,
  extractBooleanOption,
  buildWhereClause,
  buildHandlers,
} = require('./utils');
const { validateData } = require('./validationMiddleware');
const {
  withTransactionAndHooks,
  optionsWithTransaction,
  notFoundWithRollback,
} = require('./operationUtils');

function removeIdMappingFromProvided(provided, id_mapping) {
  if (Object.prototype.hasOwnProperty.call(provided, id_mapping)) {
    delete provided[id_mapping];
  }
}

function extractRawAttributes(model) {
  if (model && model.rawAttributes) {
    return model.rawAttributes;
  }
  if (model && model.prototype && model.prototype.rawAttributes) {
    return model.prototype.rawAttributes;
  }
  return {};
}

function isFieldUpdatable(key, rawAttributes, id_mapping) {
  const hasAttribute = Object.prototype.hasOwnProperty.call(rawAttributes, key);
  const isIdMappingField = key === id_mapping;
  const isAutoGenerated = !!(
    rawAttributes[key] && rawAttributes[key]._autoGenerated
  );

  return hasAttribute && !isIdMappingField && !isAutoGenerated;
}

function getUpdatableKeys(provided, rawAttributes, id_mapping) {
  const updatableKeys = [];
  const providedKeys = Object.keys(provided);

  for (let i = 0; i < providedKeys.length; i += 1) {
    const key = providedKeys[i];
    if (isFieldUpdatable(key, rawAttributes, id_mapping)) {
      updatableKeys.push(key);
    }
  }

  return updatableKeys;
}

function createFindOptions(modelOptions, id_mapping, id, transaction) {
  const findOptions = { ...modelOptions };
  findOptions.where = {};
  findOptions.where[id_mapping] = id;
  findOptions.attributes = [id_mapping];
  return optionsWithTransaction(findOptions, transaction);
}

async function handleNoUpdatableKeys(
  model,
  modelOptions,
  id_mapping,
  id,
  context
) {
  const findOptions = createFindOptions(
    modelOptions,
    id_mapping,
    id,
    context.transaction
  );
  const exists = await model.findOne(findOptions);
  if (!exists) {
    return notFoundWithRollback(context);
  }
  context.payload = { success: true, id: id };
}

function createUpdateOptions(
  modelOptions,
  ownershipWhere,
  id_mapping,
  id,
  updatableKeys,
  transaction
) {
  const updateOptions = { ...modelOptions };
  const where = buildWhereClause(ownershipWhere, id_mapping, id);
  updateOptions.where = where;
  updateOptions.fields = updatableKeys.slice();
  return optionsWithTransaction(updateOptions, transaction);
}

function extractAffectedCount(updateResult) {
  if (Array.isArray(updateResult)) {
    return updateResult[0];
  }
  return updateResult;
}

async function handleUpdatableKeys(
  model,
  provided,
  modelOptions,
  ownershipWhere,
  id_mapping,
  id,
  updatableKeys,
  context
) {
  const updateOptions = createUpdateOptions(
    modelOptions,
    ownershipWhere,
    id_mapping,
    id,
    updatableKeys,
    context.transaction
  );
  const updateResult = await model.update(provided, updateOptions);
  const affected = extractAffectedCount(updateResult);
  return affected;
}

async function validatePatchData(model, provided, validate, res) {
  if (!validate) {
    return true;
  }

  try {
    await validateData(model, provided, { isPartial: true });
    return true;
  } catch (error) {
    if (error.name === 'ValidationError') {
      res.status(400).json({
        success: false,
        error: error.message,
        details: error.details,
      });
      return false;
    }
    throw error;
  }
}

async function processPatchRequest(
  model,
  req,
  context,
  options,
  id_mapping,
  validate
) {
  const id = req.params.id;
  const provided = getProvidedValues(req);

  const isValid = await validatePatchData(
    model,
    provided,
    validate,
    context.res
  );
  if (!isValid) {
    return;
  }

  removeIdMappingFromProvided(provided, id_mapping);
  const rawAttributes = extractRawAttributes(model);
  const updatableKeys = getUpdatableKeys(provided, rawAttributes, id_mapping);

  const ownershipWhere = getOwnershipWhere(req);
  if (updatableKeys.length === 0) {
    await handleNoUpdatableKeys(model, options, id_mapping, id, context);
  } else {
    const affected = await handleUpdatableKeys(
      model,
      provided,
      options,
      ownershipWhere,
      id_mapping,
      id,
      updatableKeys,
      context
    );
    if (!affected) {
      return notFoundWithRollback(context);
    }
    context.payload = { success: true, id: id };
  }
  return context.payload;
}

function patch(model, options = {}, modelOptions = {}) {
  ensureFn(model, 'update');
  const middleware = extractMiddleware(options);
  const validate = extractBooleanOption(options, 'validate', true);
  const id_mapping = extractOption(options, 'id_mapping', 'id');
  const pre = extractOption(options, 'pre', null);
  const post = extractOption(options, 'post', null);

  const inline = filterMiddlewareFns(middleware);
  const router = express.Router({ mergeParams: true });

  const handlers = buildHandlers(inline, async (req, res) => {
    const payload = await withTransactionAndHooks(
      {
        model,
        options: { ...options, pre: pre, post: post },
        req,
        res,
        modelOptions,
        idMapping: id_mapping,
      },
      async (context) => {
        return processPatchRequest(
          model,
          req,
          context,
          modelOptions,
          id_mapping,
          validate
        );
      }
    );
    if (!res.headersSent) {
      res.json(payload);
    }
  });

  router.patch('/:id', handlers);
  router.apialize = {};
  return router;
}

module.exports = patch;
